<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jaredgrxss.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jaredgrxss.github.io/" rel="alternate" type="text/html" /><updated>2025-02-21T19:56:12-06:00</updated><id>https://jaredgrxss.github.io/feed.xml</id><title type="html">The Event Loop</title><subtitle>A place dedicated to all things engineering, technology, and algorithms.</subtitle><author><name>Jared Gross</name></author><entry><title type="html">Writing a Chess Engine in Go</title><link href="https://jaredgrxss.github.io/2025/02/20/chess-engine.html" rel="alternate" type="text/html" title="Writing a Chess Engine in Go" /><published>2025-02-20T22:45:13-06:00</published><updated>2025-02-20T22:45:13-06:00</updated><id>https://jaredgrxss.github.io/2025/02/20/chess-engine</id><content type="html" xml:base="https://jaredgrxss.github.io/2025/02/20/chess-engine.html"><![CDATA[<p>In this post, I dive deep into the process of building a chess engine using Go. From implementing sophisticated search algorithms to fine-tuning evaluation functions, this journey was as challenging as it was rewarding. </p>

<p>After many nights spent researching, following along with various online guides, and reading (a lot) of the chess programming wiki (yes, that is a thing), I was able to create an engine that faired well among various real players and other engines.</p>

<h2 class="section-heading">The Game of Chess</h2>

<p>At the heart of the engine lies the search algorithm. I began with the classic minimax approach and enhanced it using alpha-beta pruning, which significantly trimmed down the number of positions to evaluate. This optimization was crucial in achieving a responsive and efficient engine.</p>

<p>Implementing iterative deepening further allowed the engine to progressively explore deeper move sequences, ensuring that it could provide a strong move even under strict time constraints.</p>

<h2 class="section-heading">Decisions, Decisions, Decisions...</h2>

<p>The next major challenge was designing a robust evaluation function. Balancing piece values, positional advantages, and mobility metrics was key to developing an engine that could effectively assess the quality of a position.</p>

<blockquote class="blockquote">
  "Chess is the struggle against the error." – Johannes Zukertort
</blockquote>

<p>Fine-tuning these parameters required extensive testing and iteration, as I ran countless simulations to calibrate the engine’s performance. The process not only improved the engine’s decision-making but also deepened my understanding of game theory and algorithmic optimization.</p>

<h2 class="section-heading">Representing Chess, Programatically</h2>

<p>Choosing Go was a deliberate decision. Its powerful concurrency model and straightforward syntax enabled rapid prototyping and efficient handling of compute-intensive tasks, which are inherent to chess engine development. This made the integration of complex algorithms smoother and more scalable.</p>

<img class="img-fluid" src="https://source.unsplash.com/featured/?chess" alt="Chess Pieces on a Board">
<span class="caption text-muted">Chess, where every move is a step toward mastery.</span>

<h2 class="section-heading">Exponential Search?</h2>

<p>Choosing Go was a deliberate decision. Its powerful concurrency model and straightforward syntax enabled rapid prototyping and efficient handling of compute-intensive tasks, which are inherent to chess engine development. This made the integration of complex algorithms smoother and more scalable.</p>

<h2 class="section-heading">My Chess Engine Sucks Now</h2>

<p>Choosing Go was a deliberate decision. Its powerful concurrency model and straightforward syntax enabled rapid prototyping and efficient handling of compute-intensive tasks, which are inherent to chess engine development. This made the integration of complex algorithms smoother and more scalable.</p>

<h2 class="section-heading">Exponential Search, Done Better</h2>

<p>Choosing Go was a deliberate decision. Its powerful concurrency model and straightforward syntax enabled rapid prototyping and efficient handling of compute-intensive tasks, which are inherent to chess engine development. This made the integration of complex algorithms smoother and more scalable.</p>
    
<h2 class="section-heading">Evaluation: Am I Winning?</h2>

<p>Choosing Go was a deliberate decision. Its powerful concurrency model and straightforward syntax enabled rapid prototyping and efficient handling of compute-intensive tasks, which are inherent to chess engine development. This made the integration of complex algorithms smoother and more scalable.</p>


<h2 class="section-heading">Too Many Features, Too Little Time</h2>

<p>Choosing Go was a deliberate decision. Its powerful concurrency model and straightforward syntax enabled rapid prototyping and efficient handling of compute-intensive tasks, which are inherent to chess engine development. This made the integration of complex algorithms smoother and more scalable.</p>]]></content><author><name>Jared Gross</name></author><summary type="html"><![CDATA[In this post, I dive deep into the process of building a chess engine using Go. From implementing sophisticated search algorithms to fine-tuning evaluation functions, this journey was as challenging as it was rewarding.]]></summary></entry></feed>